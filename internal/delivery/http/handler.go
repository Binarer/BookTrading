package http

import (
	"booktrading/internal/domain/book"
	"booktrading/internal/domain/state"
	"booktrading/internal/domain/tag"
	"booktrading/internal/pkg/logger"
	"booktrading/internal/pkg/validator"
	"booktrading/internal/usecase"
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	_ "booktrading/docs" // docs is generated by Swag CLI, you have to import it.
	"booktrading/internal/pkg/jwt"
	"github.com/go-chi/chi/v5"
	httpSwagger "github.com/swaggo/http-swagger"
)

// @title Book Trading API
// @version 1.0
// @description API for book trading system with tag support
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host 10.3.13.28:8000
// @BasePath /
// @schemes http
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// Handler представляет HTTP обработчик
type Handler struct {
	bookUsecase  usecase.BookUsecase
	tagUsecase   usecase.TagUsecase
	stateUsecase usecase.StateUsecase
	userUsecase  usecase.UserUsecase
	jwtSvc       *jwt.Service
	validate     *validator.Validate
}

// NewHandler создает новый экземпляр HTTP обработчика
func NewHandler(
	bookUsecase usecase.BookUsecase,
	tagUsecase usecase.TagUsecase,
	stateUsecase usecase.StateUsecase,
	userUsecase usecase.UserUsecase,
	jwtSvc *jwt.Service,
) *Handler {
	return &Handler{
		bookUsecase:  bookUsecase,
		tagUsecase:   tagUsecase,
		stateUsecase: stateUsecase,
		userUsecase:  userUsecase,
		jwtSvc:       jwtSvc,
		validate:     validator.New(),
	}
}

// InitRoutes инициализирует маршруты API
func (h *Handler) InitRoutes(r chi.Router) {
	// Swagger документация
	r.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // Путь к swagger.json
	))

	// API маршруты
	r.Route("/api/v1", func(r chi.Router) {
		// Группа маршрутов для тегов
		r.Route("/tags", func(r chi.Router) {
			r.Post("/", h.createTag)
			r.Get("/", h.getAllTags)
			r.Get("/{id}", h.getTagByID)
			r.Get("/popular", h.getPopularTags)
			r.Delete("/{id}", h.deleteTag)
		})

		// Группа маршрутов для книг
		r.Route("/books", func(r chi.Router) {
			r.Post("/", h.createBook)
			r.Get("/{id}", h.getBookByID)
			r.Get("/search", h.searchBooksByTags)
			r.Post("/{id}/tags", h.addTagsToBook)
			r.Put("/{id}", h.updateBook)
			r.Patch("/{id}/state", h.updateBookState)
			r.Delete("/{id}", h.deleteBook)
			r.Get("/", h.getAllBooks)
		})

		// Группа маршрутов для состояний
		r.Route("/states", func(r chi.Router) {
			r.Post("/", h.createState)
			r.Get("/", h.getAllStates)
			r.Get("/{id}", h.getStateByID)
			r.Put("/{id}", h.updateState)
			r.Delete("/{id}", h.deleteState)
		})
	})
}

// @Summary Create a new tag
// @Description Create a new tag with the given name
// @Tags tags
// @Accept json
// @Produce json
// @Param tag body tag.CreateTagDTO true "Tag details"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} tag.Tag
// @Security BearerAuth
// @Router /api/v1/tags [post]
func (h *Handler) createTag(w http.ResponseWriter, r *http.Request) {
	var dto tag.CreateTagDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate the DTO
	if err := h.validate.Struct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, "Validation failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Create new tag
	newTag := &tag.Tag{
		Name: dto.Name,
	}

	// Save tag
	if err := h.tagUsecase.CreateTag(newTag); err != nil {
		logger.Error("Failed to create tag", err)
		http.Error(w, "Failed to create tag", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(newTag)
}

// @Summary Get tag by ID
// @Description Get tag information by ID
// @Tags tags
// @Produce json
// @Param id path int true "Tag ID"
// @Success 200 {object} tag.Tag
// @Router /api/v1/tags/{id} [get]
func (h *Handler) getTagByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid tag ID", err)
		http.Error(w, "Invalid tag ID", http.StatusBadRequest)
		return
	}

	tag, err := h.tagUsecase.GetTagByID(uint(id))
	if err != nil {
		logger.Error("Failed to get tag", err)
		http.Error(w, "Tag not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tag)
}

// @Summary Get popular tags
// @Description Get list of popular tags
// @Tags tags
// @Produce json
// @Param limit query int false "Number of tags to return"
// @Success 200 {array} tag.Tag
// @Router /api/v1/tags/popular [get]
func (h *Handler) getPopularTags(w http.ResponseWriter, r *http.Request) {
	limit := 10 // Значение по умолчанию
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil {
			limit = l
		}
	}

	tags, err := h.tagUsecase.GetPopularTags(limit)
	if err != nil {
		logger.Error("Failed to get popular tags", err)
		http.Error(w, "Failed to get popular tags", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tags)
}

// @Summary Create a new book
// @Description Create a new book with the given details
// @Tags books
// @Accept json
// @Produce json
// @Param book body book.CreateBookDTO true "Book details"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} book.Book
// @Security BearerAuth
// @Router /api/v1/books [post]
func (h *Handler) createBook(w http.ResponseWriter, r *http.Request) {
	// Получаем ID пользователя из контекста
	userID, ok := r.Context().Value("user_id").(uint)
	if !ok {
		logger.Error("Failed to get user ID from context", errors.New("user ID not found in context"))
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	var dto book.CreateBookDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.validate.Struct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Create new book
	newBook := &book.Book{
		Title:       dto.Title,
		Author:      dto.Author,
		Description: dto.Description,
		StateID:     uint(dto.StateID),
		UserID:      userID, // Связываем книгу с пользователем
	}

	// Convert tag IDs to uint
	tagIDs := make([]uint, len(dto.TagIDs))
	for i, id := range dto.TagIDs {
		tagIDs[i] = uint(id)
	}

	// Save book
	if err := h.bookUsecase.CreateBook(newBook, tagIDs); err != nil {
		logger.Error("Failed to create book", err)
		http.Error(w, "Failed to create book", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(newBook)
}

// @Summary Update a book
// @Description Update book details
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param book body book.UpdateBookDTO true "Book details"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} book.Book
// @Security BearerAuth
// @Router /api/v1/books/{id} [put]
func (h *Handler) updateBook(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var dto book.UpdateBookDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate the DTO
	if err := h.validate.Struct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, "Validation failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Update book
	updatedBook, err := h.bookUsecase.UpdateBook(uint(id), &dto)
	if err != nil {
		logger.Error("Failed to update book", err)
		http.Error(w, "Failed to update book", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedBook)
}

// @Summary Get book by ID
// @Description Get book information by ID
// @Tags books
// @Produce json
// @Param id path int true "Book ID"
// @Success 200 {object} book.Book
// @Router /api/v1/books/{id} [get]
func (h *Handler) getBookByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	book, err := h.bookUsecase.GetBookByID(uint(id))
	if err != nil {
		logger.Error("Failed to get book", err)
		http.Error(w, "Book not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Search books by tags
// @Description Search books by tag IDs
// @Tags books
// @Produce json
// @Param tagIds query []int true "Tag IDs"
// @Success 200 {array} book.Book
// @Router /api/v1/books/search [get]
func (h *Handler) searchBooksByTags(w http.ResponseWriter, r *http.Request) {
	tagIDsStr := r.URL.Query()["tagIds"]
	if len(tagIDsStr) == 0 {
		http.Error(w, "No tag IDs provided", http.StatusBadRequest)
		return
	}

	tagIDs := make([]uint, len(tagIDsStr))
	for i, idStr := range tagIDsStr {
		id, err := strconv.ParseUint(idStr, 10, 32)
		if err != nil {
			logger.Error("Invalid tag ID", err)
			http.Error(w, "Invalid tag ID", http.StatusBadRequest)
			return
		}
		tagIDs[i] = uint(id)
	}

	books, err := h.bookUsecase.GetBooksByTags(tagIDs)
	if err != nil {
		logger.Error("Failed to search books", err)
		http.Error(w, "Failed to search books", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(books)
}

// @Summary Add tags to book
// @Description Add tags to an existing book
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param tagIds body []int true "Tag IDs"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} book.Book
// @Security BearerAuth
// @Router /api/v1/books/{id}/tags [post]
func (h *Handler) addTagsToBook(w http.ResponseWriter, r *http.Request) {
	bookID, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var tagIDsInt []int64
	if err := json.NewDecoder(r.Body).Decode(&tagIDsInt); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	tagIDs := make([]uint, len(tagIDsInt))
	for i, id := range tagIDsInt {
		tagIDs[i] = uint(id)
	}

	if err := h.bookUsecase.AddTagsToBook(uint(bookID), tagIDs); err != nil {
		logger.Error("Failed to add tags to book", err)
		http.Error(w, "Failed to add tags to book", http.StatusInternalServerError)
		return
	}

	book, err := h.bookUsecase.GetBookByID(uint(bookID))
	if err != nil {
		logger.Error("Failed to get updated book", err)
		http.Error(w, "Failed to get updated book", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Create a new state
// @Description Create a new book state
// @Tags states
// @Accept json
// @Produce json
// @Param state body state.CreateStateDTO true "State object"
// @Param Authorization header string true "Bearer {token}"
// @Success 201 {object} state.State
// @Security BearerAuth
// @Router /api/v1/states [post]
func (h *Handler) createState(w http.ResponseWriter, r *http.Request) {
	var dto state.CreateStateDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	logger.Info("Creating state with name: " + dto.Name)

	if err := h.validate.Struct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	s, err := h.stateUsecase.CreateState(&dto)
	if err != nil {
		logger.Error("Failed to create state", err)
		http.Error(w, "Failed to create state", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(s)
}

// @Summary Get all states
// @Description Get list of all book states
// @Tags states
// @Produce json
// @Success 200 {array} state.State
// @Router /api/v1/states [get]
func (h *Handler) getAllStates(w http.ResponseWriter, r *http.Request) {
	states, err := h.stateUsecase.GetAllStates()
	if err != nil {
		http.Error(w, "Failed to get states", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(states)
}

// @Summary Get state by ID
// @Description Get a book state by ID
// @Tags states
// @Produce json
// @Param id path int true "State ID"
// @Success 200 {object} state.State
// @Router /api/v1/states/{id} [get]
func (h *Handler) getStateByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		http.Error(w, "Invalid state ID", http.StatusBadRequest)
		return
	}

	s, err := h.stateUsecase.GetStateByID(uint(id))
	if err != nil {
		http.Error(w, "State not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(s)
}

// @Summary Update state
// @Description Update a book state
// @Tags states
// @Accept json
// @Produce json
// @Param id path int true "State ID"
// @Param state body state.UpdateStateDTO true "State object"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} state.State
// @Security BearerAuth
// @Router /api/v1/states/{id} [put]
func (h *Handler) updateState(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		http.Error(w, "Invalid state ID", http.StatusBadRequest)
		return
	}

	var dto state.UpdateStateDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.validate.Struct(dto); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	s, err := h.stateUsecase.UpdateState(uint(id), &dto)
	if err != nil {
		http.Error(w, "Failed to update state", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(s)
}

// @Summary Delete state
// @Description Delete a book state
// @Tags states
// @Param id path int true "State ID"
// @Param Authorization header string true "Bearer {token}"
// @Success 204 "No Content"
// @Security BearerAuth
// @Router /api/v1/states/{id} [delete]
func (h *Handler) deleteState(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		http.Error(w, "Invalid state ID", http.StatusBadRequest)
		return
	}

	if err := h.stateUsecase.DeleteState(uint(id)); err != nil {
		http.Error(w, "Failed to delete state", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// @Summary Delete book
// @Description Delete a book by ID
// @Tags books
// @Param id path int true "Book ID"
// @Param Authorization header string true "Bearer {token}"
// @Success 204 "No Content"
// @Security BearerAuth
// @Router /api/v1/books/{id} [delete]
func (h *Handler) deleteBook(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	if err := h.bookUsecase.DeleteBook(uint(id)); err != nil {
		http.Error(w, "Failed to delete book", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// @Summary Delete tag
// @Description Delete a tag
// @Tags tags
// @Param id path int true "Tag ID"
// @Param Authorization header string true "Bearer {token}"
// @Success 204 "No Content"
// @Security BearerAuth
// @Router /api/v1/tags/{id} [delete]
func (h *Handler) deleteTag(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		http.Error(w, "Invalid tag ID", http.StatusBadRequest)
		return
	}

	if err := h.tagUsecase.DeleteTag(uint(id)); err != nil {
		http.Error(w, "Failed to delete tag", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// @Summary Get all tags
// @Description Get list of all tags
// @Tags tags
// @Produce json
// @Success 200 {array} tag.Tag
// @Router /api/v1/tags [get]
func (h *Handler) getAllTags(w http.ResponseWriter, r *http.Request) {
	tags, err := h.tagUsecase.GetAllTags()
	if err != nil {
		logger.Error("Failed to get tags", err)
		http.Error(w, "Failed to get tags", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tags)
}

// @Summary Update book state
// @Description Update the state of a book
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param state body book.UpdateBookStateDTO true "New state"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} book.Book
// @Security BearerAuth
// @Router /api/v1/books/{id}/state [patch]
func (h *Handler) updateBookState(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var dto book.UpdateBookStateDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.validate.Struct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	book, err := h.bookUsecase.UpdateBookState(uint(id), uint(dto.StateID))
	if err != nil {
		logger.Error("Failed to update book state", err)
		http.Error(w, "Failed to update book state", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Get all books
// @Description Get a list of all books
// @Tags books
// @Produce json
// @Success 200 {array} book.Book
// @Router /api/v1/books [get]
func (h *Handler) getAllBooks(w http.ResponseWriter, r *http.Request) {
	books, err := h.bookUsecase.GetAllBooks()
	if err != nil {
		logger.Error("Failed to get books", err)
		http.Error(w, "Failed to get books", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(books)
}

// @Summary Get all users
// @Description Get a list of all users
// @Tags users
// @Produce json
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {array} user.User
// @Security BearerAuth
// @Router /api/v1/users [get]
func (h *Handler) getAllUsers(w http.ResponseWriter, r *http.Request) {
	users, err := h.userUsecase.GetAll()
	if err != nil {
		logger.Error("Failed to get users", err)
		http.Error(w, "Failed to get users", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(users)
}

// @Summary Get user books
// @Description Get paginated list of user's books
// @Tags books
// @Produce json
// @Param id path int true "User ID"
// @Param page query int false "Page number (default: 1)"
// @Param pageSize query int false "Items per page (default: 10, max: 100)"
// @Param Authorization header string true "Bearer {token}"
// @Success 200 {object} map[string]interface{} "Returns books and pagination info"
// @Security BearerAuth
// @Router /api/v1/users/{id}/books [get]
func (h *Handler) getUserBooks(w http.ResponseWriter, r *http.Request) {
	// Получаем ID пользователя из URL
	userID, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		logger.Error("Invalid user ID", err)
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	// Получаем параметры пагинации
	page := 1
	if pageStr := r.URL.Query().Get("page"); pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	pageSize := 10
	if pageSizeStr := r.URL.Query().Get("pageSize"); pageSizeStr != "" {
		if ps, err := strconv.Atoi(pageSizeStr); err == nil && ps > 0 && ps <= 100 {
			pageSize = ps
		}
	}

	// Получаем книги пользователя
	books, total, err := h.bookUsecase.GetUserBooks(uint(userID), page, pageSize)
	if err != nil {
		logger.Error("Failed to get user books", err)
		http.Error(w, "Failed to get user books", http.StatusInternalServerError)
		return
	}

	// Формируем ответ с информацией о пагинации
	response := map[string]interface{}{
		"books": books,
		"pagination": map[string]interface{}{
			"total":      total,
			"page":       page,
			"pageSize":   pageSize,
			"totalPages": (total + int64(pageSize) - 1) / int64(pageSize),
		},
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}
