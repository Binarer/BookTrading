package http

import (
	"booktrading/internal/domain/book"
	"booktrading/internal/pkg/logger"
	"booktrading/internal/usecase"
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	swagger "github.com/swaggo/http-swagger"
	_ "booktrading/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title Book Trading API
// @version 1.0
// @description API for book trading system with tag support
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /api/v1
// @schemes http

// CreateTagRequest represents a request to create a new tag
type CreateTagRequest struct {
	Name string `json:"name" example:"fiction"`
}

// AddTagsToBookRequest represents a request to add tags to a book
type AddTagsToBookRequest struct {
	TagIDs []int64 `json:"tag_ids" example:"[1,2,3]"`
}

// Handler представляет HTTP обработчик
type Handler struct {
	tagUsecase  usecase.TagUsecase
	bookUsecase usecase.BookUsecase
}

// NewHandler создает новый экземпляр HTTP обработчика
func NewHandler(tagUsecase usecase.TagUsecase, bookUsecase usecase.BookUsecase) *Handler {
	return &Handler{
		tagUsecase:  tagUsecase,
		bookUsecase: bookUsecase,
	}
}

// InitRoutes инициализирует маршруты API
func (h *Handler) InitRoutes(r chi.Router) {
	// Swagger документация
	r.Get("/swagger/*", swagger.Handler(
		swagger.URL("/swagger/doc.json"), // Путь к swagger.json
	))

	// Группа маршрутов для тегов
	r.Route("/api/v1/tags", func(r chi.Router) {
		r.Post("/", h.createTag)
		r.Get("/{id}", h.getTagByID)
		r.Get("/popular", h.getPopularTags)
	})

	// Группа маршрутов для книг
	r.Route("/api/v1/books", func(r chi.Router) {
		r.Post("/", h.createBook)
		r.Get("/{id}", h.getBookByID)
		r.Get("/search", h.searchBooksByTags)
		r.Post("/{id}/tags", h.addTagsToBook)
	})
}

// @Summary Create a new tag
// @Description Create a new tag with the given name
// @Tags tags
// @Accept json
// @Produce json
// @Param tag body CreateTagRequest true "Tag name"
// @Success 200 {object} tag.Tag
// @Router /api/v1/tags [post]
func (h *Handler) createTag(w http.ResponseWriter, r *http.Request) {
	var request CreateTagRequest

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	tag, err := h.tagUsecase.CreateTag(request.Name)
	if err != nil {
		logger.Error("Failed to create tag", err)
		http.Error(w, "Failed to create tag", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tag)
}

// @Summary Get tag by ID
// @Description Get tag information by ID
// @Tags tags
// @Produce json
// @Param id path int true "Tag ID"
// @Success 200 {object} tag.Tag
// @Router /tags/{id} [get]
func (h *Handler) getTagByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid tag ID", err)
		http.Error(w, "Invalid tag ID", http.StatusBadRequest)
		return
	}

	tag, err := h.tagUsecase.GetTagByID(id)
	if err != nil {
		logger.Error("Failed to get tag", err)
		http.Error(w, "Tag not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tag)
}

// @Summary Get popular tags
// @Description Get list of popular tags
// @Tags tags
// @Produce json
// @Param limit query int false "Number of tags to return"
// @Success 200 {array} tag.Tag
// @Router /tags/popular [get]
func (h *Handler) getPopularTags(w http.ResponseWriter, r *http.Request) {
	limit := 10 // Значение по умолчанию
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil {
			limit = l
		}
	}

	tags, err := h.tagUsecase.GetPopularTags(limit)
	if err != nil {
		logger.Error("Failed to get popular tags", err)
		http.Error(w, "Failed to get popular tags", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tags)
}

// @Summary Create a new book
// @Description Create a new book with the given details
// @Tags books
// @Accept json
// @Produce json
// @Param book body book.Book true "Book details"
// @Success 200 {object} book.Book
// @Router /api/v1/books [post]
func (h *Handler) createBook(w http.ResponseWriter, r *http.Request) {
	var book book.Book
	if err := json.NewDecoder(r.Body).Decode(&book); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.bookUsecase.CreateBook(&book); err != nil {
		logger.Error("Failed to create book", err)
		http.Error(w, "Failed to create book", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Get book by ID
// @Description Get book information by ID
// @Tags books
// @Produce json
// @Param id path int true "Book ID"
// @Success 200 {object} book.Book
// @Router /books/{id} [get]
func (h *Handler) getBookByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	book, err := h.bookUsecase.GetBookByID(id)
	if err != nil {
		logger.Error("Failed to get book", err)
		http.Error(w, "Book not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Search books by tags
// @Description Search books that have all specified tags
// @Tags books
// @Produce json
// @Param tag_id query []int true "Tag IDs"
// @Success 200 {array} book.Book
// @Router /books/search [get]
func (h *Handler) searchBooksByTags(w http.ResponseWriter, r *http.Request) {
	tagIDsStr := r.URL.Query()["tag_id"]
	var tagIDs []int64
	for _, idStr := range tagIDsStr {
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err != nil {
			logger.Error("Invalid tag ID", err)
			http.Error(w, "Invalid tag ID", http.StatusBadRequest)
			return
		}
		tagIDs = append(tagIDs, id)
	}

	books, err := h.bookUsecase.GetBooksByTags(tagIDs)
	if err != nil {
		logger.Error("Failed to search books", err)
		http.Error(w, "Failed to search books", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(books)
}

// @Summary Add tags to book
// @Description Add multiple tags to a book
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param tags body AddTagsToBookRequest true "Tag IDs"
// @Success 200
// @Router /api/v1/books/{id}/tags [post]
func (h *Handler) addTagsToBook(w http.ResponseWriter, r *http.Request) {
	bookID, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var request AddTagsToBookRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.bookUsecase.AddTagsToBook(bookID, request.TagIDs); err != nil {
		logger.Error("Failed to add tags to book", err)
		http.Error(w, "Failed to add tags to book", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
} 