package http

import (
	"booktrading/internal/domain/book"
	"booktrading/internal/domain/tag"
	"booktrading/internal/pkg/logger"
	"booktrading/internal/pkg/validator"
	"booktrading/internal/usecase"
	"encoding/json"
	"net/http"
	"strconv"

	_ "booktrading/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/go-chi/chi/v5"
	swagger "github.com/swaggo/http-swagger"
)

// @title Book Trading API
// @version 1.0
// @description API for book trading system with tag support
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8000
// @BasePath /
// @schemes http

// Handler представляет HTTP обработчик
type Handler struct {
	tagUsecase  usecase.TagUsecase
	bookUsecase usecase.BookUsecase
}

// NewHandler создает новый экземпляр HTTP обработчика
func NewHandler(tagUsecase usecase.TagUsecase, bookUsecase usecase.BookUsecase) *Handler {
	return &Handler{
		tagUsecase:  tagUsecase,
		bookUsecase: bookUsecase,
	}
}

// InitRoutes инициализирует маршруты API
func (h *Handler) InitRoutes(r chi.Router) {
	// Swagger документация
	r.Get("/swagger/*", swagger.Handler(
		swagger.URL("/swagger/doc.json"), // Путь к swagger.json
	))

	// API маршруты
	r.Route("/api/v1", func(r chi.Router) {
		// Группа маршрутов для тегов
		r.Route("/tags", func(r chi.Router) {
			r.Post("/", h.createTag)
			r.Get("/{id}", h.getTagByID)
			r.Get("/popular", h.getPopularTags)
		})

		// Группа маршрутов для книг
		r.Route("/books", func(r chi.Router) {
			r.Post("/", h.createBook)
			r.Get("/{id}", h.getBookByID)
			r.Get("/search", h.searchBooksByTags)
			r.Post("/{id}/tags", h.addTagsToBook)
			r.Put("/{id}", h.updateBook)
		})
	})
}

// @Summary Create a new tag
// @Description Create a new tag with the given name
// @Tags tags
// @Accept json
// @Produce json
// @Param tag body tag.CreateTagDTO true "Tag details"
// @Success 200 {object} tag.Tag
// @Router /api/v1/tags [post]
func (h *Handler) createTag(w http.ResponseWriter, r *http.Request) {
	var dto tag.CreateTagDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate the DTO
	if err := validator.ValidateStruct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, "Validation failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Create new tag
	newTag := &tag.Tag{
		Name: dto.Name,
	}

	// Save tag
	if err := h.tagUsecase.CreateTag(newTag); err != nil {
		logger.Error("Failed to create tag", err)
		http.Error(w, "Failed to create tag", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(newTag)
}

// @Summary Get tag by ID
// @Description Get tag information by ID
// @Tags tags
// @Produce json
// @Param id path int true "Tag ID"
// @Success 200 {object} tag.Tag
// @Router /api/v1/tags/{id} [get]
func (h *Handler) getTagByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid tag ID", err)
		http.Error(w, "Invalid tag ID", http.StatusBadRequest)
		return
	}

	tag, err := h.tagUsecase.GetTagByID(id)
	if err != nil {
		logger.Error("Failed to get tag", err)
		http.Error(w, "Tag not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tag)
}

// @Summary Get popular tags
// @Description Get list of popular tags
// @Tags tags
// @Produce json
// @Param limit query int false "Number of tags to return"
// @Success 200 {array} tag.Tag
// @Router /api/v1/tags/popular [get]
func (h *Handler) getPopularTags(w http.ResponseWriter, r *http.Request) {
	limit := 10 // Значение по умолчанию
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil {
			limit = l
		}
	}

	tags, err := h.tagUsecase.GetPopularTags(limit)
	if err != nil {
		logger.Error("Failed to get popular tags", err)
		http.Error(w, "Failed to get popular tags", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tags)
}

// @Summary Create a new book
// @Description Create a new book with the given details
// @Tags books
// @Accept json
// @Produce json
// @Param book body book.CreateBookDTO true "Book details"
// @Success 200 {object} book.Book
// @Router /api/v1/books [post]
func (h *Handler) createBook(w http.ResponseWriter, r *http.Request) {
	var dto book.CreateBookDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate the DTO
	if err := validator.ValidateStruct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Create new book
	newBook := &book.Book{
		Title:       dto.Title,
		Author:      dto.Author,
		Description: dto.Description,
		State:       dto.State,
		Photos:      dto.Photos,
	}

	// Create book through usecase
	if err := h.bookUsecase.CreateBook(newBook, dto.TagIDs); err != nil {
		logger.Error("Failed to create book", err)
		http.Error(w, "Failed to create book: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Return created book
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(newBook)
}

// @Summary Update a book
// @Description Update book details
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param book body book.UpdateBookDTO true "Book details"
// @Success 200 {object} book.Book
// @Router /api/v1/books/{id} [put]
func (h *Handler) updateBook(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var dto book.UpdateBookDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate the DTO
	if err := validator.ValidateStruct(dto); err != nil {
		logger.Error("Validation failed", err)
		http.Error(w, "Validation failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Update book
	updatedBook, err := h.bookUsecase.UpdateBook(id, &dto)
	if err != nil {
		logger.Error("Failed to update book", err)
		http.Error(w, "Failed to update book", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedBook)
}

// @Summary Get book by ID
// @Description Get book information by ID
// @Tags books
// @Produce json
// @Param id path int true "Book ID"
// @Success 200 {object} book.Book
// @Router /api/v1/books/{id} [get]
func (h *Handler) getBookByID(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	book, err := h.bookUsecase.GetBookByID(id)
	if err != nil {
		logger.Error("Failed to get book", err)
		http.Error(w, "Book not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(book)
}

// @Summary Search books by tags
// @Description Search books that have all specified tags
// @Tags books
// @Produce json
// @Param tag_id query []int true "Tag IDs"
// @Success 200 {array} book.Book
// @Router /api/v1/books/search [get]
func (h *Handler) searchBooksByTags(w http.ResponseWriter, r *http.Request) {
	tagIDsStr := r.URL.Query()["tag_id"]
	var tagIDs []int64
	for _, idStr := range tagIDsStr {
		id, err := strconv.ParseInt(idStr, 10, 64)
		if err != nil {
			logger.Error("Invalid tag ID", err)
			http.Error(w, "Invalid tag ID", http.StatusBadRequest)
			return
		}
		tagIDs = append(tagIDs, id)
	}

	books, err := h.bookUsecase.GetBooksByTags(tagIDs)
	if err != nil {
		logger.Error("Failed to search books", err)
		http.Error(w, "Failed to search books", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(books)
}

// @Summary Add tags to book
// @Description Add multiple tags to a book
// @Tags books
// @Accept json
// @Produce json
// @Param id path int true "Book ID"
// @Param tags body []int64 true "Tag IDs"
// @Success 200
// @Router /api/v1/books/{id}/tags [post]
func (h *Handler) addTagsToBook(w http.ResponseWriter, r *http.Request) {
	bookID, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		logger.Error("Invalid book ID", err)
		http.Error(w, "Invalid book ID", http.StatusBadRequest)
		return
	}

	var tagIDs []int64
	if err := json.NewDecoder(r.Body).Decode(&tagIDs); err != nil {
		logger.Error("Failed to decode request body", err)
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.bookUsecase.AddTagsToBook(bookID, tagIDs); err != nil {
		logger.Error("Failed to add tags to book", err)
		http.Error(w, "Failed to add tags to book", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}
